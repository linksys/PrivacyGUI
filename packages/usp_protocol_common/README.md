# USP Protocol Common

This package serves as the **Shared Kernel** (The Contract) for the USP Client POC monorepo. It contains the official TR-369 Protocol Buffer definitions, generated Dart code, and shared utilities for handling USP Messages and Records.

## üì¶ Core Components

### 1. Protobuf Definitions (`proto/`)

The source of truth for the communication protocol.

*   **`usp_msg.proto`**: Defines the **USP Message**. Contains the actual commands and responses (e.g., `Get`, `Set`, `Notify`).
    *   *Analogy*: The letter inside the envelope.
*   **`usp_record.proto`**: Defines the **USP Record**. The transport-agnostic envelope containing routing (`to_id`, `from_id`) and security info.
    *   *Analogy*: The physical envelope with addresses.
*   **`usp_transport.proto`**: A custom wrapper for tunneling USP Records over **gRPC**.

### 2. Dart Implementation (`lib/src/`)

Provides a high-level API to interact with the raw Protobuf classes.

*   **`generated/`**: The Dart code generated by `protoc`. Avoid editing these files directly.
*   **`dtos/`**: **Data Transfer Objects**. Dart-friendly classes used by the application layer.
*   **`converter/`**: Utilities to serialize/deserialize between DTOs and Protobuf bytes.

-----

## üõ†Ô∏è Usage Guide

### üì± For Frontend (Flutter Client)

The frontend uses this package to **construct requests** and **parse responses**.

**Typical Workflow:**

1.  **Create a Request**:
    Use the helper classes to build a USP Message.
    ```dart
    import 'package:usp_protocol_common/usp_protocol_common.dart';

    final request = UspMsg(
      header: Header(msgId: '123', msgType: Header_MsgType.GET),
      body: Body(request: Request(get: Get(paramPaths: ['Device.DeviceInfo.'])))
    );
    ```

2.  **Wrap in Record**:
    Encapsulate the message into a Record for transport.
    ```dart
    final record = UspRecord(
      toId: 'proto::agent',
      fromId: 'proto::controller',
      payload: request.writeToBuffer(), // Serialize Msg to bytes
    );
    ```

3.  **Send via Transport**:
    Serialize the Record and send it (e.g., via gRPC).
    ```dart
    final bytes = record.writeToBuffer();
    // transport.send(bytes);
    ```

### ü§ñ For Backend (Simulator / Agent)

The backend uses this package to **decode requests**, **route messages**, and **generate responses**.

**Typical Workflow:**

1.  **Receive & Decode**:
    Parse the incoming raw bytes into a Record.
    ```dart
    import 'package:usp_protocol_common/usp_protocol_common.dart';

    void onDataReceived(List<int> data) {
      final record = UspRecord.fromBuffer(data);
      print('Received message from: ${record.fromId}');
    }
    ```

2.  **Process Message**:
    Extract the payload (USP Message) and handle the command.
    ```dart
    final msg = UspMsg.fromBuffer(record.payload);
    if (msg.header.msgType == Header_MsgType.GET) {
       // Handle Get Request...
    }
    ```

3.  **Send Response**:
    Create a response message, wrap it in a new Record (swapping to/from IDs), and send it back.

-----

## üîÑ Development Workflow

### Updating the Protocol

If you modify any `.proto` files in the `proto/` directory:

1.  **Run the Generator**:
    Execute the following Melos script to regenerate the Dart code.
    ```bash
    melos run proto:gen
    ```

2.  **Verify**:
    Check `lib/src/generated/` to ensure the new fields or messages are present.
